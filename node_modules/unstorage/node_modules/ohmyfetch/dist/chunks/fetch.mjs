import destr from 'destr';
import { joinURL, withQuery } from 'ufo';

class FetchError extends Error {
  constructor() {
    super(...arguments);
    this.name = "FetchError";
  }
}
function createFetchError(request, response) {
  const message = `${response.status} ${response.statusText} (${request.toString()})`;
  const error = new FetchError(message);
  Object.defineProperty(error, "request", { get() {
    return request;
  } });
  Object.defineProperty(error, "response", { get() {
    return response;
  } });
  Object.defineProperty(error, "data", { get() {
    return response.data;
  } });
  const stack = error.stack;
  Object.defineProperty(error, "stack", { get() {
    return normalizeStack(stack);
  } });
  return error;
}
function normalizeStack(stack = "") {
  return stack.split("\n").filter((l) => !l.includes("createFetchError") && !l.includes("at $fetch") && !l.includes("processTicksAndRejections")).join("\n");
}

const payloadMethods = ["patch", "post", "put"];
function setHeader(options, _key, value) {
  const key = _key.toLowerCase();
  options.headers = options.headers || {};
  if ("set" in options.headers) {
    options.headers.set(key, value);
  } else if (Array.isArray(options.headers)) {
    const existingHeader = options.headers.find(([header]) => header.toLowerCase() === key);
    if (existingHeader) {
      existingHeader[1] = value;
    } else {
      options.headers.push([key, value]);
    }
  } else {
    const existingHeader = Object.keys(options.headers).find((header) => header.toLowerCase() === key);
    options.headers[existingHeader || key] = value;
  }
}
function createFetch({ fetch }) {
  const raw = async function(request, opts = {}) {
    if (typeof request === "string") {
      if (opts.baseURL) {
        request = joinURL(opts.baseURL, request);
      }
      if (opts.params) {
        request = withQuery(request, opts.params);
      }
      if (opts.body && opts.body.toString() === "[object Object]" && payloadMethods.includes(opts.method?.toLowerCase() || "")) {
        opts.body = JSON.stringify(opts.body);
        setHeader(opts, "content-type", "application/json");
      }
    }
    const response = await fetch(request, opts);
    const text = await response.text();
    const parseFn = opts.parseResponse || destr;
    response.data = parseFn(text);
    if (!response.ok) {
      throw createFetchError(request, response);
    }
    return response;
  };
  const $fetch = function(request, opts) {
    return raw(request, opts).then((r) => r.data);
  };
  $fetch.raw = raw;
  return $fetch;
}

export { FetchError as F, createFetchError as a, createFetch as c, setHeader as s };
