"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIPXHandler = void 0;
const path_1 = require("path");
const os_1 = require("os");
const ipx_1 = require("ipx");
const functions_1 = require("@netlify/functions");
const ufo_1 = require("ufo");
const etag_1 = __importDefault(require("etag"));
const http_1 = require("./http");
function createIPXHandler({ cacheDir = (0, path_1.join)((0, os_1.tmpdir)(), 'ipx-cache'), basePath = '/_ipx', ...opts } = {}) {
    const ipx = (0, ipx_1.createIPX)({ ...opts, dir: (0, path_1.join)(cacheDir, 'cache') });
    const handler = async (event, _context) => {
        const host = event.headers.host;
        const protocol = event.headers['x-forwarded-proto'] || 'http';
        let domains = opts.domains || [];
        const requestEtag = event.headers['if-none-match'];
        const url = event.path.replace(basePath, '');
        const [modifiers = '_', ...segments] = url.substr(1).split('/');
        let id = decodeURIComponent(segments.join('/'));
        const requestHeaders = {};
        const isLocal = !id.startsWith('http');
        if (isLocal) {
            id = `${protocol}://${host}${id.startsWith('/') ? '' : '/'}${id}`;
            if (event.headers.cookie) {
                requestHeaders.cookie = event.headers.cookie;
            }
            if (event.headers.authorization) {
                requestHeaders.authorization = event.headers.authorization;
            }
        }
        else {
            if (typeof domains === 'string') {
                domains = domains.split(',').map(s => s.trim());
            }
            const hosts = domains.map(domain => (0, ufo_1.parseURL)(domain, 'https://').host);
            // Parse id as URL
            const parsedUrl = (0, ufo_1.parseURL)(id, 'https://');
            // Check host
            if (!parsedUrl.host) {
                return {
                    statusCode: 403,
                    body: 'Hostname is missing: ' + id
                };
            }
            if (!hosts.find(host => parsedUrl.host === host)) {
                return {
                    statusCode: 403,
                    body: 'Hostname is missing: ' + parsedUrl.host
                };
            }
        }
        const { response, cacheKey, responseEtag } = await (0, http_1.loadSourceImage)({
            cacheDir,
            url: id,
            requestEtag,
            modifiers,
            isLocal,
            requestHeaders
        });
        if (response) {
            return response;
        }
        const res = await (0, ipx_1.handleRequest)({
            url: `/${modifiers}/${cacheKey}`,
            headers: event.headers
        }, ipx);
        const body = typeof res.body === 'string' ? res.body : res.body.toString('base64');
        res.headers.etag = responseEtag || (0, etag_1.default)(body);
        delete res.headers['Last-Modified'];
        if (requestEtag && requestEtag === res.headers.etag) {
            return {
                statusCode: 304,
                message: 'Not Modified'
            };
        }
        return {
            statusCode: res.statusCode,
            message: res.statusMessage,
            headers: res.headers,
            isBase64Encoded: typeof res.body !== 'string',
            body
        };
    };
    return (0, functions_1.builder)(handler);
}
exports.createIPXHandler = createIPXHandler;
